# Rivest Shamir Adleman
 cryptography, 338 points

## Description
 A while back I wrote a Python implementation of RSA, but Python's really slow at maths. Especially generating primes.

## Hints
 There are two possible ways to get the flag ;-)

## Solution
 My first instinct when I get a modulus is put it through both factordb and YAFU, with factordb giving us the factors this time, the problem was trivial.

```python
from Crypto.Util.number import *

def extended_gcd(aa, bb):
    lastremainder, remainder = abs(aa), abs(bb)
    x, lastx, y, lasty = 0, 1, 1, 0
    while remainder:
        lastremainder, (quotient, remainder) = remainder, divmod(
            lastremainder, remainder)
        x, lastx = lastx - quotient*x, x
        y, lasty = lasty - quotient*y, y
    return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)


def modinv(a, m):
    g, x, y = extended_gcd(a, m)
    if g != 1:
        raise ValueError
    return x % m

n = 5215102981058174620100754813213017625443626121109099133656454487932754235228856710661075956048331662593471061936196995326042367228980357932444477256496372200491821105922086202549125972429240337409176104237690646206864286971669895986447543904638596421264915837230690039800948447210554706127145724519079487023930504508462885777797916915752532472831523596571484341342780877665593787078959178539369282442522815729401991936772080063808078804309866694041173404657777517753433918322041736500126265865045225739241983004392226366771900174432875800986183772576663590650132115754645829772406067103501861326445534174181231077263
p = 58754030774905986805754122995310081662217884210168479550129875193424398870745444673926050610118197084042202162420044553461740174815697964254570199939394803548997633592060223756279974260864378745120001533514186672141428133398599326104981445779780014073764199910798520251506148673445046102194538255507437319319
q = n//p
phi = (p-1)*(q-1)
e = 5
d = modinv(e, phi)
cipher = int('0x20ba6aee3bd1c1b751082bfcb667bad8b632504336f3994606594f4ab756f66e3a24f9782da3a07280aa67cd875e6e33f2c573abf7b7901e5cd428ab8ceb6738b13536fee35a90dac7c2175e41eea5977dfbaff6e68f5b1f6fa3673cba64923b02bff899e2535f7d09afecae6774260ce8be4867f45e63571a2055c645a03dd05d9dd596eec273e1ef4352d712deffc658745d17853cbe5c3bc138574703c994be5374e3ac73279f51f23ec7e55b25b6ab904e06562025c380ce4c4d5ddffc2d649fbd1421b82090d01f24c70254187f1f435e64d7b2bf8395915da3cfdd8680187566b6a51e48146b4a40f08aebdedca8a08557ea3dc5efc2c50377b5764a8c', 16)
print(long_to_bytes(pow(cipher, d, n)))
```

Looking at the small e, I think a small exponent attack should be possible as well, which might be the other way the hint was referring to.

## Flag
>rtcp{f1xed_pr*me-0r_low_e?}
